// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by terraform-codegen and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in README.md and
//     CONTRIBUTING.md located at the root of this package.
//
// ----------------------------------------------------------------------------

package google

import (
	"fmt"

	"github.com/hashicorp/terraform/helper/schema"
	compute "google.golang.org/api/compute/v1"
)

func resourceComputeInstanceGroup() *schema.Resource {
	return &schema.Resource{
		Create: resourceComputeInstanceGroupCreate,
		Read:   resourceComputeInstanceGroupRead,
		Update: resourceComputeInstanceGroupUpdate,
		Delete: resourceComputeInstanceGroupDelete,

		Importer: &schema.ResourceImporter{
			State: resourceComputeInstanceGroupImport,
		},

		Schema: map[string]*schema.Schema{
			"zone": {
				Type:             schema.TypeString,
				Required:         true,
				DiffSuppressFunc: compareSelfLinkOrResourceName,
			},
			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"name": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"named_ports": {
				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"port": {
							Type:     schema.TypeInt,
							Optional: true,
						},
					},
				},
			},
			"network": {
				Type:             schema.TypeString,
				Optional:         true,
				DiffSuppressFunc: compareSelfLinkOrResourceName,
			},
			"region": {
				Type:             schema.TypeString,
				Optional:         true,
				DiffSuppressFunc: compareSelfLinkOrResourceName,
			},
			"subnetwork": {
				Type:             schema.TypeString,
				Optional:         true,
				DiffSuppressFunc: compareSelfLinkOrResourceName,
			},
			"creation_timestamp": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"id": {
				Type:     schema.TypeInt,
				Computed: true,
			},
			"project": &schema.Schema{
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
			"self_link": &schema.Schema{
				Type:     schema.TypeString,
				Computed: true,
			},
		},
	}
}

func resourceComputeInstanceGroupCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)

	project, err := getProject(d, config)
	if err != nil {
		return err
	}

	obj := map[string]interface{}{
		"description": expandComputeInstanceGroupDescription(d.Get("description")),
		"name":        expandComputeInstanceGroupName(d.Get("name")),
		"namedPorts":  expandComputeInstanceGroupNamedPorts(d.Get("named_ports")),
		"network":     expandComputeInstanceGroupNetwork(d.Get("network")),
		"region":      expandComputeInstanceGroupRegion(d.Get("region")),
		"subnetwork":  expandComputeInstanceGroupSubnetwork(d.Get("subnetwork")),
		"zone":        expandComputeInstanceGroupZone(d.Get("zone")),
	}

	url, err := replaceVars(d, config, "https://www.googleapis.com/compute/v1/projects/{{project}}/zones/{{zone}}/instanceGroups")
	if err != nil {
		return err
	}
	res, err := Post(config, url, obj)
	if err != nil {
		return fmt.Errorf("Error creating InstanceGroup: %s", err)
	}

	// Store the ID now
	id, err := replaceVars(d, config, "")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	op := &compute.Operation{}
	err = Convert(res, op)
	if err != nil {
		return err
	}

	waitErr := computeOperationWait(config.clientCompute, op, project, "Creating InstanceGroup")
	if waitErr != nil {
		// The resource didn't actually create
		d.SetId("")
		return waitErr
	}

	return resourceComputeInstanceGroupRead(d, meta)
}

func resourceComputeInstanceGroupRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)

	project, err := getProject(d, config)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "https://www.googleapis.com/compute/v1/projects/{{project}}/zones/{{zone}}/instanceGroups/{{name}}")
	if err != nil {
		return err
	}
	res, err := Get(config, url)
	if err != nil {
		return handleNotFoundError(err, d, fmt.Sprintf("ComputeInstanceGroup %q", d.Id()))
	}

	d.Set("creation_timestamp", flattenComputeInstanceGroupCreationTimestamp(res["creationTimestamp"]))
	d.Set("description", flattenComputeInstanceGroupDescription(res["description"]))
	d.Set("id", flattenComputeInstanceGroupId(res["id"]))
	d.Set("name", flattenComputeInstanceGroupName(res["name"]))
	d.Set("named_ports", flattenComputeInstanceGroupNamedPorts(res["namedPorts"]))
	d.Set("network", flattenComputeInstanceGroupNetwork(res["network"]))
	d.Set("region", flattenComputeInstanceGroupRegion(res["region"]))
	d.Set("subnetwork", flattenComputeInstanceGroupSubnetwork(res["subnetwork"]))
	d.Set("zone", flattenComputeInstanceGroupZone(res["zone"]))
	d.Set("self_link", res["selfLink"])
	d.Set("project", project)

	return nil
}

func resourceComputeInstanceGroupUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)

	project, err := getProject(d, config)
	if err != nil {
		return err
	}

	obj := map[string]interface{}{
		"description": expandComputeInstanceGroupDescription(d.Get("description")),
		"name":        expandComputeInstanceGroupName(d.Get("name")),
		"namedPorts":  expandComputeInstanceGroupNamedPorts(d.Get("named_ports")),
		"network":     expandComputeInstanceGroupNetwork(d.Get("network")),
		"region":      expandComputeInstanceGroupRegion(d.Get("region")),
		"subnetwork":  expandComputeInstanceGroupSubnetwork(d.Get("subnetwork")),
		"zone":        expandComputeInstanceGroupZone(d.Get("zone")),
	}

	url, err := replaceVars(d, config, "https://www.googleapis.com/compute/v1/projects/{{project}}/zones/{{zone}}/instanceGroups/{{name}}")
	if err != nil {
		return err
	}
	res, err := Put(config, url, obj)
	if err != nil {
		return fmt.Errorf("Error updating InstanceGroup %q: %s", d.Id(), err)
	}

	op := &compute.Operation{}
	err = Convert(res, op)
	if err != nil {
		return err
	}

	err = computeOperationWait(config.clientCompute, op, project, "Updating InstanceGroup")
	if err != nil {
		return err
	}

	return resourceComputeInstanceGroupRead(d, meta)
}

func resourceComputeInstanceGroupDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)

	project, err := getProject(d, config)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "https://www.googleapis.com/compute/v1/projects/{{project}}/zones/{{zone}}/instanceGroups/{{name}}")
	if err != nil {
		return err
	}
	res, err := Delete(config, url)
	if err != nil {
		return fmt.Errorf("Error deleting InstanceGroup %q: %s", d.Id(), err)
	}

	op := &compute.Operation{}
	err = Convert(res, op)
	if err != nil {
		return err
	}

	err = computeOperationWait(config.clientCompute, op, project, "Updating InstanceGroup")
	if err != nil {
		return err
	}

	return nil
}

func resourceComputeInstanceGroupImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	d.Set("", d.Id())
	return []*schema.ResourceData{d}, nil
}

func flattenComputeInstanceGroupCreationTimestamp(v interface{}) interface{} {
	return v
}

func flattenComputeInstanceGroupDescription(v interface{}) interface{} {
	return v
}

func flattenComputeInstanceGroupId(v interface{}) interface{} {
	return v
}

func flattenComputeInstanceGroupName(v interface{}) interface{} {
	return v
}

func flattenComputeInstanceGroupNamedPorts(v interface{}) interface{} {
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"name": flattenComputeInstanceGroupNamedPortsName(original["name"]),
			"port": flattenComputeInstanceGroupNamedPortsPort(original["port"]),
		})
	}
	return transformed
}
func flattenComputeInstanceGroupNamedPortsName(v interface{}) interface{} {
	return v
}
func flattenComputeInstanceGroupNamedPortsPort(v interface{}) interface{} {
	return v
}

func flattenComputeInstanceGroupNetwork(v interface{}) interface{} {
	return v
}

func flattenComputeInstanceGroupRegion(v interface{}) interface{} {
	return v
}

func flattenComputeInstanceGroupSubnetwork(v interface{}) interface{} {
	return v
}

func flattenComputeInstanceGroupZone(v interface{}) interface{} {
	return v
}

func expandComputeInstanceGroupDescription(v interface{}) interface{} {
	return v
}

func expandComputeInstanceGroupName(v interface{}) interface{} {
	return v
}

func expandComputeInstanceGroupNamedPorts(v interface{}) interface{} {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformed["name"] =
			expandComputeInstanceGroupNamedPortsName(original["name"])
		transformed["port"] =
			expandComputeInstanceGroupNamedPortsPort(original["port"])

		req = append(req, transformed)
	}
	return req
}
func expandComputeInstanceGroupNamedPortsName(v interface{}) interface{} {
	return v
}
func expandComputeInstanceGroupNamedPortsPort(v interface{}) interface{} {
	return v
}

func expandComputeInstanceGroupNetwork(v interface{}) interface{} {
	return v
}

func expandComputeInstanceGroupRegion(v interface{}) interface{} {
	return v
}

func expandComputeInstanceGroupSubnetwork(v interface{}) interface{} {
	return v
}

func expandComputeInstanceGroupZone(v interface{}) interface{} {
	return v
}
